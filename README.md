# MultiCamVision

## 1. Небольшая вводная

Внутренняя матрица камеры имеет следующий вид:

```math
K = \begin{bmatrix}
f_{x} &  \gamma & c_{x} \\
0 & f_{y} & c_{y} \\
0 & 0 & 1  
\end{bmatrix} 
```

где, ``f_{x}, f_{y}`` - фокусник расстояние ``X`` и ``Y``,
``c_{x}, c_{y}`` - координаты ``X`` и ``Y`` оптического центра в плоскости изображения,
``\gamma`` - перекос между осями. Обычно значение равно ``1`` в `OpenCV` значение равно ``0``.

### Методы калибровки камеры

Существует 3 основных вида калибровки камеры:
1. **Калибровка по шаблону.** Лучший способ выполнить калибровку — это сделать несколько изображений объекта или шаблона известных размеров с разных точек зрения. Метод шахматной доски самый распространенный способ калибровки камеры данным методом.
2. **Геометрические примитивы.** Иногда в сцене присутствуют другие геометрические примитивы, например прямые линии и точки пересечений, которые также можно использовать для калибровки.
3. **На основе глубокого машинного обучения.** Когда у нас очень ограничены возможности управления настройками изображения (например, у нас есть единственное изображение сцены), при этом всё еще возможно получить информацию для калибровки камеры, используя Метод глубокого машинного обучения.

В качестве основного метода использовался принцип **калибровки по шаблону**

## 2. Калибровка камеры (что сделал, что попробовал).

Установил камеры, распечатал [шаблон шахматной доски](https://i.stack.imgur.com/fP0Im.jpg) и сделал около 50 изображений
![Шахматная доска с двух ракурсов](./doc/img/merged_camera.jpg "Шахматная доска с двух ракурсов")

Нахожу углы шахматной доски. В `OpenCV` есть встроенная функция `findChessboardCorners()`, которая ищет шахматную доску и возвращает координаты углов.
```python
retval, corners = cv2.findChessboardCorners(image, patternSize, flags)
```

На входе:
* **image** — Исходный вид шахматной доски. Должен быть цветным или 8-битным изображением в оттенках.
* **patternSize** — Количество клеток шахматной доски по вертикали и горизонтали.
* **flags** — Различные флаги. О них надо побеспокоится только тогда, когда что-то не работает. Оставил по умолчанию.

На выходе получим:
* **retval** - `bool` - получилось ли найти значение. 
* **corners** — Выходной массив обнаруженных углов.

Для увеличения точности обнаружения углов воспользовался функцией `cornerSubPix()` - берет клетки исходного изображения и ищет лучшее местоположение углов клеток, расположенных по соседству.
```python
cv2.cornerSubPix(image, corners, winSize, zeroZone, criteria)
```

На входе:
* **image** — Исходное изображение
* **corners** — Начальные координаты входных углов и уточненные координаты, которые передаются в вызывающую функцию
* **winSize** — Половина длины стороны окна поиска
* **zeroZone** — Половина размера мертвой области в середине зоны поиска, по которой суммирование в приведенной ниже формуле не выполняется.  Значение (-1, -1) указывает, что такого размера нет
* **criteria** — Критерии прекращения итерационного процесса уточнения угла. То есть процесс уточнения координат угла прекращается либо после выполнения заданного количества итераций `criteria.maxcount`, либо при достижении заданной точности `criteria.epsilon` между итерациями

После нахождения углов отображаю полученные результаты

![Шахматная доска с двух ракурсов c найденными углами](./doc/img/merged_camera_findChess.jpg "Шахматная доска с двух ракурсов c найденными углами")  

Последний шаг калибровки состоит в том, чтобы передать 3D-точки в мировых координатах и их 2D-положения на всех изображениях в метод `calibrateCamera()` OpenCV.

```python
retval, cameraMatrix, distCoeffs, rvecs, tvecs = cv2.calibrateCamera(objectPoints, imagePoints, imageSize)
```

На входе:
* **objectPoints** — Вектор векторов 3D точек. Внешний вектор содержит столько же элементов, сколько число представлений образца
* **imagePoints** — Вектор векторов 2D точек
* **imageSize** — Размер изображения

На выходе:
* **retval** - `bool` - получилось ли откалибровать камеру.
* **cameraMatrix** — Внутренняя матрица камеры
* **distCoeffs** — Коэффициенты искажения объектива
* **rvecs** — Вращение указано как вектор 3×1. Направление вектора задает ось вращения, а величина вектора — угол поворота
* **tvecs** — 3×1 вектор смещения

После выполнения всех операций получил следующие значения:

1. **Внутренняя матрица камеры 1 и 2**
```math
K_{1} = \begin{bmatrix}
614.07307041 &  0 & 372.03673972 \\
0 & 618.00929889 & 264.49475922 \\
0 & 0 & 1  
\end{bmatrix} 
```

```math
K_{2} = \begin{bmatrix}
808.48307724 &  0 & 326.0952272 \\
0 & 806.25644072 & 276.19123945 \\
0 & 0 & 1  
\end{bmatrix} 
```

2. **Коэффициенты искажения объектива:**
```math
dist_{1} = \begin{bmatrix}
0.12445894 & -1.0647863 & -0.0015978 & 0.03230406 & 1.58352286 
\end{bmatrix} 
```

```math
dist_{2} = \begin{bmatrix}
0.1287737 & 0.09347506 & 0.01534844 & 0.00730035 & -5.05120021
\end{bmatrix} 
```

3. **Вектор вращение:**
```python
rvecs = (array([[-0.32240054],[-0.34252039],[-1.55632932]]),array([[-0.28559202],[-0.31905349],[-1.57841346]]), 
 array([[-0.47947263],[-0.18393932],[-1.60720693]]),array([[-0.56892046],[-0.05340807],[-1.59801901]]),
 array([[-0.55105672],[-0.02315844],[-1.60471257]]),array([[-0.50763403],[ 0.03978979],[-1.6360104 ]]),
 array([[-0.18474416],[-0.38078414],[-1.48518181]]),array([[-0.06431901],[-0.56262602],[-1.44269507]]), 
 array([[-0.09058823],[-0.49847336],[-1.44658585]]),array([[-0.08089551],[-0.49568062],[-1.44261085]]), 
 array([[-0.34570025],[-0.35109756],[-1.5809466 ]]),array([[-0.10114604],[-0.5425689 ],[-1.44832022]]), 
 array([[-0.19293431],[-0.53094086],[-1.48034307]]),array([[-0.18173941],[-0.43259767],[-1.46698416]]), 
 array([[-0.21684125],[-0.36435296],[-1.50074335]]),array([[-0.457121  ],[-0.29826559],[-1.58878954]]), 
 array([[-0.53367253],[-0.31933748],[-1.56002288]]), array([[-0.54481386],[-0.30613914],[-1.58642023]]), 
 array([[-0.38860928],[-0.27922509],[-1.61013843]]), array([[-0.50190365],[-0.29232837],[-1.60706414]]), 
 array([[-0.25082766],[-0.19237643],[-1.6218931 ]]), array([[-0.20213557],[-0.16154397],[-1.61085172]]), 
 array([[-0.21661545],[-0.18992503],[-1.61045262]]), array([[-0.22386015],[-0.15126312],[-1.60689908]]), 
 array([[-0.26373015],[-0.26503312],[-1.60900796]]), array([[-0.31572747],[-0.29074577],[-1.61289239]]), 
 array([[-0.36621367],[-0.22071123],[-1.61704808]]), array([[-0.4018172 ],[-0.19394853],[-1.63380915]]), 
 array([[-0.44588557],[-0.16118355],[-1.67383003]]), array([[-0.47353799],[-0.10095424],[-1.70266414]]), 
 array([[-0.44941941],[-0.13352464],[-1.6840357 ]]), array([[-0.36970448],[-0.21291569],[-1.63771693]]), 
 array([[-0.26636295],[-0.28297006],[-1.55194788]]), array([[-0.20985194],[-0.30372139],[-1.5139867 ]]), 
 array([[-0.10156167],[-0.36698109],[-1.46435111]]), array([[-0.39077673],[-0.22992322],[-1.65287079]]), 
 array([[-0.42105868],[-0.23008193],[-1.62554355]]), array([[-0.33236107],[-0.17515337],[-1.61952761]]), 
array([[-0.35793771],[-0.30469402],[-1.58228884]]), array([[-0.28851324],[-0.30540657],[-1.57424836]]))
```

```python
rvecs2= (array([[ 0.05312109],[ 0.30526552],[-1.48506459]]), array([[ 0.08332495],[ 0.31754058],[-1.51841297]]), 
array([[ 0.20490643],[ 0.19163357],[-1.47466395]]), array([[ 0.34429059],[ 0.08410546],[-1.48995934]]), 
array([[ 0.31098331],[ 0.106001  ],[-1.47686801]]), array([[ 0.30706964],[ 0.10651903],[-1.47281252]]), 
array([[ 0.02823501],[ 0.30834789],[-1.50555762]]), array([[ 0.27618087],[ 0.05290791],[-1.48609615]]), 
array([[ 0.26004474],[ 0.05120577],[-1.50640687]]), array([[ 0.21985108],[ 0.10291405],[-1.49221265]]), 
array([[ 0.19632057],[ 0.13248103],[-1.48891518]]), array([[ 0.19255023],[ 0.08607606],[-1.49912653]]), 
array([[ 0.16959304],[ 0.20565423],[-1.46075577]]), array([[ 0.16142998],[ 0.18975646],[-1.47545656]]), 
array([[-0.08612511],[ 0.31736736],[-1.50897622]]), array([[-0.16535309],[ 0.27672649],[-1.47522766]]), 
array([[-0.16844975],[ 0.2733077 ],[-1.49428852]]), array([[-0.01699985],[ 0.3751544 ],[-1.50300515]]), 
array([[-0.14496256],[ 0.30270731],[-1.51653519]]), array([[ 0.10376523],[ 0.43562501],[-1.53025892]]), 
array([[ 0.1424263 ],[ 0.46193326],[-1.51610655]]), array([[ 0.15041002],[ 0.44035531],[-1.52215577]]), 
array([[ 0.14090946],[ 0.4753844 ],[-1.50730039]]), array([[ 0.09988808],[ 0.37308236],[-1.5299482 ]]), 
array([[ 0.06461202],[ 0.33891042],[-1.538224  ]]), array([[ 1.39887735e-03],[ 3.81121863e-01],[-1.51911926e+00]]), 
array([[-0.03876122],[ 0.42807068],[-1.5131071 ]]), array([[-0.08489366],[ 0.41388016],[-1.53197585]]), 
array([[-0.1346587 ],[ 0.53023389],[-1.53718942]]), array([[-0.2081933 ],[ 0.5545921 ],[-1.52612799]]), 
array([[-0.21080227],[ 0.58751251],[-1.5261604 ]]), array([[-0.13755248],[ 0.52917487],[-1.52971684]]), 
array([[-0.01682938],[ 0.45358753],[-1.52193448]]), array([[ 0.07796319],[ 0.3894097 ],[-1.48195419]]), 
array([[ 0.16110331],[ 0.31436843],[-1.46602251]]), array([[ 0.20498597],[ 0.23852321],[-1.46797513]]), 
array([[ 0.2858118 ],[ 0.20274388],[-1.45640192]]), array([[-0.04200647],[ 0.4227061 ],[-1.5352534 ]]), 
array([[ 0.00488713],[ 0.46020272],[-1.50349158]]), array([[ 0.01670607],[ 0.32548772],[-1.50753136]]), 
array([[ 0.07757704],[ 0.3306132 ],[-1.51118711]])) 
```

4. **Вектор смещения:**
```python
tvecs = (array([[-3.33538143],[-2.93405589],[18.61573504]]), array([[-2.46688847],[ 0.22215816],[19.34052476]]), 
array([[-3.10309079],[-0.18552387],[20.56646216]]), array([[-2.61958265],[-1.64632123],[20.73568389]]), 
array([[-2.05390038],[-0.41509591],[20.21555678]]), array([[-1.5019813 ],[ 0.45024643],[19.99224709]]), 
array([[-2.10455117],[-0.74545788],[17.11688274]]), array([[-2.31660151],[-1.26421868],[15.83243037]]), 
array([[-2.70686808],[-1.83763447],[16.69523559]]), array([[-2.84577039],[-2.73882782],[16.90305834]]), 
array([[-3.97384658],[-2.68990935],[18.61792082]]), array([[-2.87543528],[-3.34964802],[16.64710673]]), 
array([[-3.942804  ],[-2.73068765],[16.83954454]]), array([[-2.61856646],[-2.59829802],[18.33566892]]), 
array([[-3.24908493],[-1.26706971],[17.84633609]]), array([[-0.18546265],[ 2.21178456],[21.76341461]]), 
array([[-0.03356958],[ 2.39439807],[22.46964654]]), array([[-0.28434265],[ 3.46598738],[23.66390157]]), 
array([[-5.39320957],[-2.13182665],[19.34954149]]), array([[-0.31723277],[ 4.09012585],[24.00567966]]), 
array([[-2.22713681],[-0.15512631],[20.78890498]]), array([[-2.31695712],[-0.13489309],[20.06395845]]), 
array([[-2.23236987],[ 0.54886123],[19.1804815 ]]), array([[-2.28376423],[ 1.09146183],[19.33543256]]), 
array([[-2.30998151],[-0.6046092 ],[19.12434231]]), array([[-2.31444927],[-1.05706164],[19.26065547]]), 
array([[-3.16726407],[-0.83753488],[20.28719198]]), array([[-3.81030006],[-0.33630043],[20.4941703 ]]), 
array([[-4.51347489],[-0.79482132],[21.52406962]]), array([[-4.79976119],[-0.87601327],[22.65704446]]), 
array([[-4.82997244],[-0.76929271],[22.2450562 ]]), array([[-4.14279518],[-1.04666077],[21.39326051]]), 
array([[-2.52292685],[-1.48667861],[20.56285372]]), array([[-1.50763346],[-1.49699967],[20.39659434]]), 
array([[ 0.21725003],[-0.93546589],[19.29801454]]), array([[-5.86878204],[ 0.6220381 ],[20.71884424]]), 
array([[-5.43840709],[ 1.37436882],[19.98218494]]), array([[-4.83334724],[ 2.20418991],[19.5055257 ]]), 
array([[-4.20566351],[ 1.33653219],[18.68446041]]), array([[-2.833467  ],[ 1.19632737],[18.83597352]]))
```

```python
tvecs2 = (array([[-5.39709846],[ 0.34125146],[21.2236782 ]]), array([[-4.39833877],[ 2.61142957],[23.62633131]]), 
array([[-4.38596514],[ 3.28027627],[20.85781111]]), array([[-4.64653371],[ 3.51145346],[20.0405431 ]]), 
array([[-5.07347279],[ 2.53934832],[20.25177273]]), array([[-5.17458139],[ 1.57010355],[19.93788815]]), 
array([[-5.99977031],[ 0.47028081],[21.52087391]]), array([[-5.23221199],[ 1.19892453],[19.34735309]]), 
array([[-5.17268925],[ 1.77685366],[19.35813343]]), array([[-6.16905628],[ 2.79044995],[20.31186175]]), 
array([[-7.03806694],[ 2.61226632],[20.52595895]]), array([[-6.31210715],[ 1.57523477],[19.97299991]]), 
array([[-4.94173219],[ 0.77879455],[21.24895015]]), array([[-5.37935428],[ 2.19348493],[21.02461866]]), 
array([[-1.82158263],[ 3.13643793],[26.37648405]]), array([[-1.54330018],[ 2.87380601],[27.11981234]]), 
array([[-1.63997208],[ 2.97709322],[28.54753532]]), array([[-7.31851753],[ 0.38538908],[22.55641357]]), 
array([[-1.58232532],[ 3.29611422],[29.38081869]]), array([[-3.94753367],[ 1.51446514],[24.46208685]]), 
array([[-4.16598323],[ 1.88264323],[23.86207139]]), array([[-4.22303755],[ 3.04995891],[23.55954694]]), 
array([[-4.24093695],[ 3.34125112],[23.96529139]]), array([[-4.31970838],[ 2.0949877 ],[22.84477051]]), 
array([[-4.31134057],[ 1.65059479],[22.73941885]]), array([[-4.8424923 ],[ 1.21331361],[23.53182977]]), 
array([[-5.53428292],[ 1.42934703],[24.26365894]]), array([[-7.91120254],[ 0.2892762 ],[25.79175431]]), 
array([[-6.16183129],[-0.35967446],[25.7617691 ]]), array([[-7.21848119],[-0.26076642],[26.5284996 ]]), 
array([[-7.07873271],[-0.2741902 ],[26.62802991]]), array([[-6.40507307],[-0.06894015],[25.72749009]]), 
array([[-5.778142  ],[ 0.25526003],[24.74079672]]), array([[-4.60713442],[ 0.32948263],[23.87913124]]), 
array([[-3.38862308],[ 0.65608755],[23.35141241]]), array([[-2.835533  ],[ 1.02872648],[22.82969563]]), 
array([[-1.90823856],[ 1.83627612],[22.36672892]]), array([[-7.56358814],[ 1.76455355],[25.35624934]]), 
array([[-6.6955017 ],[ 3.85552283],[25.18826845]]), array([[-6.23010035],[ 3.78336817],[23.97673158]]), 
array([[-4.80843929],[ 3.70253687],[23.82817539]]))
```


## 3. Самописная библиотека по калибровке камер(ы)

Написал мини библиотеку для тестирования работы и упрощения кода (__возможны баги__)

Копируем репозиторий `git clone https://github.com/EvilFis/MultiCamVision.git`

Устанавливаем необходимые библиотеки

`pip install -r requirements.txt`

Файл `.env.dist` переименовать в `.env`. Поля в файле поменять на правильные адреса

```
RTSP_CAMERA_MAIN=rtsp://<name>:<password>@<IP>:554/cam/realmonitor?channel=1&subtype=1
RTSP_CAMERA_ADDED=rtsp://<name>:<password>@<IP>:554/cam/realmonitor?channel=1&subtype=1
```

Файл `calibrate.py` содержит код для сбора датасета с дальнейшей калибровкой камер(ы).

### Создание класса камера
Для инициализации и вывода потока видео с камеры необходимо воспользоваться следующей структурой

-——

```python
from cam import Camera

camera = Camera(camera_id=0,  # ID камеры 
                show_frame=True,  # Показ окна вывода
                vertical_flip=True,  # Вертикальное отражение
                save_video=False # Сохранение видео потока
                )
                
camera.initialize()
```

Закрытие окна вывода осуществляется по нажатию клавиши **`q`**

Если необходимо объединить несколько камер в одно окно вывода, проще воспользоваться следующей структурой

-——

```python
camera1 = Camera(camera_id=0, show_frame=False)
camera2 = Camera(camera_id=1, show_frame=False)

while True:
    
    frame1 = camera1.read_frame()
    frame2 = camera2.read_frame()
    
    frames = Camera.stack_images(scale=0.5, img_array=([frame1, frame2]))
    
    cv2.imshow(“Split frames”, frames)
    
```

### Сбор датасета
Для того чтобы собрать датасет изображений для дальнейшей калибровки камеры необходимо воспользоваться функцией `create_dataset()`

-——

```python
from cam import create_dataset

create_dataset(camera_list=[camera1, camera2],  # Список инициализированный камер
               dir=PATH_IMG,  # Путь где будет сохраняться изображения (по умолчанию ./camera_img)
               zoom=.8. # Уменьшение или увеличения изображения для вывода
               )
```

### Калибровка камеры
Для калибровки камеры необходимо воспользоваться `camera_calibrate`

-——

```python
import cv2
from cam import camera_calibrate

criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

mtx, dist, rvecs, tvecs = camera_calibrate(boar_size=(6, 9),  # Размер доски для распознования
                 criteria=criteria
                 images_path=PATH_IMG,  # Путь до изображений
                 draw_chessboard=False  # Отрисовывать точки на изображениях (появляется дополнительное окно для каждой фотографии)
                 )
```

Функция возвращает следующие переменные `mtx, dist, rvecs, tvecs`, где:
На выходе:
* **mtx** — Внутренняя матрица камеры
* **dist** — Коэффициенты искажения объектива.
* **rvecs** — Вращение указано как вектор 3×1. Направление вектора задает ось вращения, а величина вектора — угол поворота.
* **tvecs** — 3×1 вектор смещения.

## 4. Получение мировых координат из изображения

Разбираюсь